import time
import threading
import random
from web3 import Web3
from web3.middleware import geth_poa_middleware
import json
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(threadName)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Configuration Parameters
ETH_NODE_URL = "http://127.0.0.1:8545"
CONTRACT_ADDRESS = "0x"
CONTRACT_ABI = json.loads('''
[
    {
        "inputs": [
            {"internalType": "bytes32", "name": "recordId", "type": "bytes32"},
            {"internalType": "bytes", "name": "modifiedData", "type": "bytes"},
            {"internalType": "bytes", "name": "signature", "type": "bytes"}
        ],
        "name": "updateMedicalRecord",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "bytes32", "name": "recordId", "type": "bytes32"}],
        "name": "getRecordHash",
        "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
        "stateMutability": "view",
        "type": "function"
    }
]
''')
TEST_ACCOUNTS = [
    "0xAccount1Address",
    "0xAccount2Address",
]
RECORD_IDS = [Web3.keccak(text=f"EMR_{i}") for i in range(100)]
CONCURRENT_USER_RANGES = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
TEST_DURATION = 30
GAS_LIMIT = 300000
GAS_PRICE = Web3.to_wei(20, 'gwei')

# Initialize Web3 Connection
w3 = Web3(Web3.HTTPProvider(ETH_NODE_URL))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)

if not w3.is_connected():
    raise ConnectionError("Failed to connect to Ethereum node. Check node address.")

contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=CONTRACT_ABI)

# Utility Functions
def generate_random_medical_data():
    data_types = [
        b"BP:120/80,HR:72,TEMP:36.5",
        b"BP:135/85,HR:80,TEMP:36.8",
        b"DIAGNOSIS:Hypertension,Medication:Lisinopril",
        b"LAB:Glucose=5.6,HbA1c=5.7",
    ]
    return random.choice(data_types)

def sign_data(private_key, data):
    hash_data = Web3.keccak(data)
    signed = w3.eth.account.sign_hash(hash_data, private_key=private_key)
    return signed.signature

def send_update_transaction(account, private_key, record_id):
    try:
        modified_data = generate_random_medical_data()
        signature = sign_data(private_key, modified_data + record_id)
        
        nonce = w3.eth.get_transaction_count(account)
        tx = contract.functions.updateMedicalRecord(
            recordId=record_id,
            modifiedData=modified_data,
            signature=signature
        ).build_transaction({
            "from": account,
            "nonce": nonce,
            "gas": GAS_LIMIT,
            "gasPrice": GAS_PRICE,
        })
        
        signed_tx = w3.eth.account.sign_transaction(tx, private_key=private_key)
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        
        receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=30)
        if receipt.status == 1:
            logger.info(f"Transaction successful: {tx_hash.hex()}, Record ID: {record_id.hex()[:8]}...")
            return True
        else:
            logger.error(f"Transaction failed: {tx_hash.hex()}, Status code: {receipt.status}")
            return False
    except Exception as e:
        logger.error(f"Transaction sending failed: {str(e)}")
        return False

# Throughput Test Core
def throughput_test(concurrent_users):
    logger.info(f"Test started: Concurrent users = {concurrent_users}, Test duration = {TEST_DURATION}s")
    
    user_accounts = random.sample(TEST_ACCOUNTS, min(concurrent_users, len(TEST_ACCOUNTS)))
    user_private_keys = [
        "0xYourTestAccountPrivateKey1",
        "0xYourTestAccountPrivateKey2",
    ][:concurrent_users]
    
    successful_txs = 0
    start_time = time.time()
    end_time = start_time + TEST_DURATION
    
    with ThreadPoolExecutor(max_workers=concurrent_users, thread_name_prefix="User") as executor:
        while time.time() < end_time:
            futures = []
            for idx in range(concurrent_users):
                account = user_accounts[idx % len(user_accounts)]
                private_key = user_private_keys[idx % len(user_private_keys)]
                record_id = random.choice(RECORD_IDS)
                
                future = executor.submit(
                    send_update_transaction,
                    account=account,
                    private_key=private_key,
                    record_id=record_id
                )
                futures.append(future)
            
            for future in as_completed(futures):
                if future.result():
                    successful_txs += 1
            
            time.sleep(0.1)
    
    elapsed_time = time.time() - start_time
    tps = successful_txs / elapsed_time
    logger.info(f"Test finished: Concurrent users = {concurrent_users}, Successful TXs = {successful_txs}, "
                f"Elapsed time = {elapsed_time:.2f}s, TPS = {tps:.2f}")
    
    return {
        "concurrent_users": concurrent_users,
        "successful_txs": successful_txs,
        "elapsed_time": elapsed_time,
        "tps": tps
    }

# Main Test Flow
if __name__ == "__main__":
    test_results = []
    
    for users in CONCURRENT_USER_RANGES:
        result = throughput_test(users)
        test_results.append(result)
    
    print("\n" + "="*50)
    print("RBDMS Throughput Test Summary Report")
    print("="*50)
    for res in test_results:
        print(f"Concurrent Users: {res['concurrent_users']:3d} | "
              f"Successful TXs: {res['successful_txs']:4d} | "
              f"Elapsed Time: {res['elapsed_time']:6.2f}s | "
              f"TPS: {res['tps']:5.2f}")
    print("="*50)

    import csv
    with open("rbdms_throughput_test.csv", "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=["concurrent_users", "successful_txs", "elapsed_time", "tps"])
        writer.writeheader()
        writer.writerows(test_results)
    print("\nTest results saved to rbdms_throughput_test.csv")

# Would you like me to generate a **visualization script** for plotting the throughput test results (matching Fig.6 in the paper)?
